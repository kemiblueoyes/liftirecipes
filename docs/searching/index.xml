<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LIFTI – Searching</title>
    <link>https://mikegoatly.github.io/lifti/docs/searching/</link>
    <description>Recent content in Searching on LIFTI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	  <atom:link href="https://mikegoatly.github.io/lifti/docs/searching/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: The LIFTI Query Syntax</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t want to use advanced queries? You&amp;rsquo;ll want to configure the &lt;a href=&#34;../simple-queries&#34;&gt;simple query parser&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;quick-examples&#34;&gt;Quick examples&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;West&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;West&lt;/strong&gt; must appear in the text &lt;a href=&#34;#exact-word-matches&#34;&gt;exactly&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?Wst&lt;/td&gt;
&lt;td&gt;Words that &lt;a href=&#34;#fuzzy-match-&#34;&gt;fuzzy match&lt;/a&gt; with &lt;strong&gt;wst&lt;/strong&gt; must appear in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?3,2?Wst&lt;/td&gt;
&lt;td&gt;Words that &lt;a href=&#34;#fuzzy-match-&#34;&gt;fuzzy match&lt;/a&gt; with &lt;strong&gt;wst&lt;/strong&gt; must appear in the text, with a specified max edit distance and max sequential edits.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;title=West&lt;/td&gt;
&lt;td&gt;A &lt;a href=&#34;#field-restrictions-field&#34;&gt;field restricted&lt;/a&gt; search. &lt;strong&gt;West&lt;/strong&gt; must appear in the &lt;em&gt;&lt;strong&gt;title&lt;/strong&gt;&lt;/em&gt; field of an indexed object.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;doc*&lt;/td&gt;
&lt;td&gt;Words that starts with &lt;strong&gt;doc&lt;/strong&gt;ument must appear in the text. &lt;a href=&#34;#wildcard-matching&#34;&gt;See wildcard matching&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%%ing&lt;/td&gt;
&lt;td&gt;Words that starts with any two letters and end with &lt;strong&gt;ing&lt;/strong&gt;, e.g. &lt;em&gt;doing&lt;/em&gt;. &lt;a href=&#34;#wildcard-matching&#34;&gt;See wildcard matching&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west &amp;amp; wing&lt;/td&gt;
&lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href=&#34;#and-&#34;&gt;and&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west wing&lt;/td&gt;
&lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href=&#34;#and-&#34;&gt;and&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text - the default operator is &amp;amp; if none is specified between search words.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west | wing&lt;/td&gt;
&lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href=&#34;#or-&#34;&gt;or&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west ~ wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; and &lt;strong&gt;wing&lt;/strong&gt; must appear &lt;a href=&#34;#near--and-n&#34;&gt;near to each other&lt;/a&gt; (within 5 words - the default) in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west ~3 wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; and &lt;strong&gt;wing&lt;/strong&gt; must appear &lt;a href=&#34;#near--and-n&#34;&gt;near to each other&lt;/a&gt; (within &lt;strong&gt;3&lt;/strong&gt; words) in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west ~&amp;gt; wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must be &lt;a href=&#34;#near-following--and-n&#34;&gt;followed by&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; closely (within 5 words - the default) in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west ~3&amp;gt; wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must be &lt;a href=&#34;#near-following--and-n&#34;&gt;followed by&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; closely (within &lt;strong&gt;3&lt;/strong&gt; words) in the text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;west &amp;gt; wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must &lt;a href=&#34;#following-&#34;&gt;precede&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; anywhere in the text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ldquo;the west wing&amp;rdquo;&lt;/td&gt;
&lt;td&gt;The words &lt;strong&gt;the west wing&lt;/strong&gt; must appear &lt;a href=&#34;#sequential-text-&#34;&gt;in sequence&lt;/a&gt; in the indexed text.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ldquo;notr* dam*&amp;rdquo;&lt;/td&gt;
&lt;td&gt;You can use &lt;a href=&#34;#wildcard-matching&#34;&gt;wildcards&lt;/a&gt; and &lt;a href=&#34;#fuzzy-match-&#34;&gt;fuzzy matching&lt;/a&gt; in a &lt;a href=&#34;#sequential-text-&#34;&gt;sequential text&lt;/a&gt; query. In this case, a word starting with &lt;strong&gt;notr&lt;/strong&gt; must be immediately followed by a word starting with &lt;strong&gt;dam&lt;/strong&gt;, e.g. &lt;strong&gt;Notre Dame&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Search terms can be combined and placed in parenthesis:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ldquo;west wing&amp;rdquo; ~ &amp;ldquo;oval office&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;West wing&lt;/strong&gt; must appear near &lt;strong&gt;Oval Office&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(west | east) &amp;amp; wing&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;west wing&lt;/strong&gt; or &lt;strong&gt;east wing&lt;/strong&gt; must appear in the document.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;query-operators&#34;&gt;Query Operators&lt;/h2&gt;
&lt;h3 id=&#34;exact-word-matches&#34;&gt;Exact word matches&lt;/h3&gt;
&lt;p&gt;Any text in a query will be tokenized using to the provided tokenizer,
enforcing the same word stemming, case/accent sensitivity rules as used in the index.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;fuzzy-match-&#34;&gt;Fuzzy match (&lt;code&gt;?&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;By prefixing a search term with &lt;code&gt;?&lt;/code&gt; a fuzzy matching algorithm will be used to match the search term against the index. You can optionally specify the maximum edit distance and maximum number of sequential edits
for a specific search term using the formats:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?{max edits},{max sequential edits}?term&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For example &lt;code&gt;?2,1?food&lt;/code&gt; will search for &amp;ldquo;food&amp;rdquo; with a maximum number of edits of 2, and maximum sequential edits of 1.&lt;/p&gt;
&lt;p&gt;You can omit one or the other parameter if required, so &lt;code&gt;?2?food&lt;/code&gt; will only set the maximum number of edits to 2, leaving the maximum sequential edits at the default value. If you want to only include
the maximum number of sequential edits, then you must include a leading comma in the parameter set, e.g. &lt;code&gt;?,2?food&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See &lt;a href=&#34;../fuzzy-matching&#34;&gt;Fuzzy Matching&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h4 id=&#34;defaulting-search-terms-to-fuzzy-matching&#34;&gt;Defaulting search terms to fuzzy matching&lt;/h4&gt;
&lt;p&gt;By default LIFTI will treat a search term as an &lt;a href=&#34;#exact-word-matches&#34;&gt;exact word match&lt;/a&gt;, however &lt;a href=&#34;../index-construction/withqueryparser/#configuring-the-default-lifti-queryparser&#34;&gt;you can configure the index&lt;/a&gt; so that any search term (apart from those containing wildcards)
will be treated as a fuzzy match.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;wildcard-matching&#34;&gt;Wildcard matching&lt;/h3&gt;
&lt;p&gt;Any search term containing &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; will be considered a wildcard match, where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; matches zero or more characters&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; matches any single character. You can use multiple &lt;code&gt;%&lt;/code&gt; in a row to indicate an exact number of characters that need to be matched.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;foo*&lt;/code&gt; would match occurrences of &lt;code&gt;food&lt;/code&gt; and &lt;code&gt;football&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*ing&lt;/code&gt; would match &lt;code&gt;drifting&lt;/code&gt; and &lt;code&gt;flying&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%%%ld&lt;/code&gt; would match &lt;code&gt;could&lt;/code&gt; and &lt;code&gt;mould&lt;/code&gt; (but &lt;strong&gt;not&lt;/strong&gt; &lt;code&gt;should&lt;/code&gt;, because it has 4 letters before the &lt;code&gt;ld&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%%p*&lt;/code&gt; matches words starting with any two characters followed by &lt;code&gt;g&lt;/code&gt;, then any zero or more characters, e.g. &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;caps&lt;/code&gt;, &lt;code&gt;duped&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;and-&#34;&gt;And (&lt;code&gt;&amp;amp;&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;The and operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) Performs an intersection of two intermediate query results, combining word positions for successful matches.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Food &amp;amp; Burger&lt;/code&gt; searches for items containing both &lt;code&gt;&amp;quot;food&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;burger&amp;quot;&lt;/code&gt; at any position, and in any field.&lt;/p&gt;
&lt;p&gt;(Alternatively &lt;code&gt;Food Burger&lt;/code&gt; will have the same effect as the default operator between query parts is an &lt;code&gt;&amp;amp;&lt;/code&gt;.)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;or-&#34;&gt;Or (&lt;code&gt;|&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;Performs a union of two intermediate query results. Where an items appears in both sets, word positions are combined into one list.&lt;/p&gt;
&lt;p&gt;Restricts results to same field by default: &lt;strong&gt;false&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;bracketing-expressions&#34;&gt;Bracketing expressions&lt;/h3&gt;
&lt;p&gt;Brackets can be used to group expressions together.&lt;/p&gt;
&lt;p&gt;e.g. &lt;code&gt;(food &amp;amp; cake) | (cheese &amp;amp; biscuit)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;field-restrictions-field&#34;&gt;Field restrictions (&lt;code&gt;field=...&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;These allow for restricting searches within a given field.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;title=analysis | body=(chocolate &amp;amp; cake)&lt;/code&gt; Searches for items with &lt;code&gt;&amp;quot;analysis&amp;quot;&lt;/code&gt; in the title field &lt;em&gt;or both&lt;/em&gt; &lt;code&gt;&amp;quot;chocolate&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;cake&amp;quot;&lt;/code&gt; in the body field.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;title=analysis food&lt;/code&gt; Searches for items with &lt;code&gt;&amp;quot;analysis&amp;quot;&lt;/code&gt; in the title field &lt;em&gt;and&lt;/em&gt; &lt;code&gt;&amp;quot;food&amp;quot;&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; field.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sequential-text-&#34;&gt;Sequential text (&lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;Placing quotes around a search phrase will enforce that the words all appear
immediately next to each other in the source text.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;cheese burger&amp;quot;&lt;/code&gt; will only match items that have text containing &lt;code&gt;&amp;quot;cheese&amp;quot;&lt;/code&gt; followed immediately by &lt;code&gt;&amp;quot;burger&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;near--and-n&#34;&gt;Near (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~n&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;The near operator performs a positional intersection of two results based on the position of the word in a field.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;~&lt;/code&gt; operator requires that words must be within 5 words of one another. This can value can be controlled by specifying a number, e.g. &lt;code&gt;~4&lt;/code&gt; to restrict to only returning results within 4 words of one another.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cheese ~ cake&lt;/code&gt; will return items containing the words &lt;code&gt;&amp;quot;cheese&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;cake&amp;quot;&lt;/code&gt; in either order, up to 5 words apart, e.g. &lt;code&gt;&amp;quot;the cake was made with cheese&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;I like cheese and cake&amp;quot;&lt;/code&gt; would both match, but &lt;code&gt;&amp;quot;cake is never to be considered a substitute for cheese&amp;quot;&lt;/code&gt; would not.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;near-following--and-n&#34;&gt;Near following (&lt;code&gt;~&amp;gt;&lt;/code&gt; and &lt;code&gt;~n&amp;gt;&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;Same as Near (&lt;code&gt;~&lt;/code&gt;) except that order is important in the positional intersection.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cheese ~&amp;gt; cake&lt;/code&gt; will match &lt;code&gt;&amp;quot;cheese and cake&amp;quot;&lt;/code&gt; but not &lt;code&gt;&amp;quot;cake and cheese&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;following-&#34;&gt;Following (&lt;code&gt;&amp;gt;&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;Same as Near Following (&lt;code&gt;~&amp;gt;&lt;/code&gt;) except there are no constraints on how far apart the words can be.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cheese &amp;gt; cake&lt;/code&gt; will match any text where &lt;code&gt;&amp;quot;cheese&amp;quot;&lt;/code&gt; precedes &lt;code&gt;&amp;quot;cake&amp;quot;&lt;/code&gt; in a given field.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Fuzzy Matching</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/fuzzy-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/fuzzy-matching/</guid>
      <description>
        
        
        &lt;p&gt;Fuzzy matches can be explicitly searched for using the &lt;a href=&#34;../lifti-query-syntax/#fuzzy-match-&#34;&gt;LIFTI query syntax&lt;/a&gt;, or implied as the default for searches by
&lt;a href=&#34;../../index-construction/withqueryparser/#configuring-the-default-lifti-queryparser&#34;&gt;configuring the index&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;LIFTI uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Levenshtein_distance&#34;&gt;Levenshtein distance&lt;/a&gt; to perform fuzzy matches between a search term and tokens in the index.
The distance between two words is the number of edits that are required to match them, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insertions: fid would match fi&lt;strong&gt;n&lt;/strong&gt;d&lt;/li&gt;
&lt;li&gt;deletions: foood would match food&lt;/li&gt;
&lt;li&gt;substitutions: frnd would match f&lt;strong&gt;i&lt;/strong&gt;nd&lt;/li&gt;
&lt;li&gt;transpositions: fnid would match f&lt;strong&gt;in&lt;/strong&gt;d - Transpositions are a special case, because although two characters are affected, it is considered a single edit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting Levenshtein distance between any matched term and the search term is used to reduce the score of the match. This means that documents containing
words that are closer matches will typically be surfaced higher up in the search results.&lt;/p&gt;
&lt;h3 id=&#34;configuration&#34;&gt;Configuration&lt;/h3&gt;
&lt;p&gt;To prevent a &lt;a href=&#34;https://en.wikipedia.org/wiki/Combinatorial_explosion&#34;&gt;combinatorial explosion&lt;/a&gt; of potential matches, LIFTI provides two control mechanisms for fuzzy matching:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Maximum number of edits&lt;/strong&gt; - the total number of edits that can be used in any potential match. The default for this value is calculated as &lt;code&gt;search term length/2&lt;/code&gt; which allows for a larger number of
edits for longer search terms. Search terms of just a single character will not allow any edits, as the resulting value will be zero (the formula is an integer calculation).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maximum number of sequential edits&lt;/strong&gt; - the maximum number of edits that can be found sequentially in any potential match. The default for this value is calculated as &lt;code&gt;max(1, search term length/4)&lt;/code&gt;. This
default allows for a growing number of sequential edits, however this will never drop below a value of one.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When providing your own overrides for these calculations, be aware that if your configuration for either  results in a value of zero, then the fuzzy match will become an exact match, as no edits will be allowed.&lt;/p&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;p&gt;With a max edits of &lt;strong&gt;3&lt;/strong&gt; and max sequential edits of &lt;strong&gt;1&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;feed&lt;/strong&gt; will &lt;em&gt;not&lt;/em&gt; match &lt;strong&gt;food&lt;/strong&gt; because it requires two sequential edits&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;redy&lt;/strong&gt; will &lt;em&gt;not&lt;/em&gt; match &lt;strong&gt;friendly&lt;/strong&gt; because it requires 4 insertions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Default values can be &lt;a href=&#34;../../index-construction/withqueryparser/#queryparserbuilder-options&#34;&gt;configured at the index level&lt;/a&gt;, and can either be expressed as a static value,
or a value calculated from the length of the search term.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Simple Queries</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/simple-queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/simple-queries/</guid>
      <description>
        
        
        &lt;p&gt;When you have &lt;a href=&#34;../../index-construction/withsimplequeryparser&#34;&gt;configured an index to use the simple query parser&lt;/a&gt; you can no longer
make use of the full LIFTI query syntax in your queries, however you can still configure the simple query parser to treat all search
terms as &lt;a href=&#34;../fuzzy-matching&#34;&gt;fuzzy matches&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Search terms are simply combined together with &lt;code&gt;and&lt;/code&gt;s or &lt;code&gt;or&lt;/code&gt;s, depending on your configuration, and punctuation is stripped out as per your
index tokenization rules.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Manually Constructing Query Objects</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/manually-constructing-queries/</link>
      <pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/manually-constructing-queries/</guid>
      <description>
        
        
        &lt;p&gt;You can manually construct a &lt;code&gt;Query&lt;/code&gt; using any combination of &lt;code&gt;IQueryPart&lt;/code&gt;s, but take care to normalize any text to match in the same way that it has been indexed. You can do this using either the &lt;code&gt;IIndexTokenizer&lt;/code&gt; for the index, or if specific tokenization rules have been &lt;a href=&#34;../index-construction/withobjecttokenization&#34;&gt;configured for a field&lt;/a&gt;, then the tokenizer for that field:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;tokenizer&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;DefaultTokenizer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;query&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Query&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AndQueryOperator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ExactWordQueryPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;tokenizer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Normalize&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)),&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ExactWordQueryPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;tokenizer&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Normalize&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;there&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;query-parts&#34;&gt;Query Parts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;IQueryPart&lt;/code&gt;s come in two flavors:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Operators - these contain other &lt;code&gt;IQueryParts&lt;/code&gt;, combining the results that they return according to certain rules, e.g. &lt;code&gt;AndQueryPart&lt;/code&gt; and &lt;code&gt;OrQueryPart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Textual - these work the &lt;a href=&#34;../using-the-index-navigator/&#34;&gt;&lt;code&gt;IIndexNavigator&lt;/code&gt;&lt;/a&gt; to query the index for matches appropriate to them, e.g. &lt;code&gt;ExactWordQueryPart&lt;/code&gt;, &lt;code&gt;FuzzyMatchQueryPart&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;textual-query-parts&#34;&gt;Textual query parts&lt;/h3&gt;
&lt;h4 id=&#34;exactwordquerypartstring-word&#34;&gt;ExactWordQueryPart(string word)&lt;/h4&gt;
&lt;p&gt;Searches the index for words that exactly match &lt;code&gt;word&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;fuzzymatchquerypartstring-word-ushort-maxeditdistance--4-ushort-maxsequentialedits--1&#34;&gt;FuzzyMatchQueryPart(string word, ushort maxEditDistance = 4, ushort maxSequentialEdits = 1)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Performs a &lt;a href=&#34;../lifti-query-syntax#fuzzy-match-&#34;&gt;fuzzy match&lt;/a&gt; against the index.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;maxEditDistance&lt;/code&gt;: The maximum of edits allowed for any given match. The higher this value, the more divergent matches will be.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxSequentialEdits&lt;/code&gt; The maximum number of edits that are allowed to appear sequentially. By default this is 1, which forces matches to be more similar to the search criteria&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;wildcardquerypartireadonlylistltwildcardqueryfragmentgt-fragments&#34;&gt;WildcardQueryPart(IReadOnlyList&amp;lt;WildcardQueryFragment&amp;gt; fragments)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A &lt;code&gt;WildcardQueryPart&lt;/code&gt; consists of multiple &lt;code&gt;WildcardQueryFragment&lt;/code&gt;s that are processed sequentially to match tokens in the index. They can be constructed using the following methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WildcardQueryFragment.MultiCharacter()&lt;/code&gt; - matches zero or more characters in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WildcardQueryFragment.SingleCharacter()&lt;/code&gt; - matches any single character in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WildcardQueryFragment.CreateText(string text)&lt;/code&gt; - exact matches a fragment of text at whatever point has been reached in the index.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wildcard&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;WildcardQueryPart&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;WildcardQueryFragment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SingleCharacter&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;WildcardQueryFragment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SingleCharacter&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;WildcardQueryFragment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;CreateText&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;d&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Would translate to the LIFTI query &lt;code&gt;%%d&lt;/code&gt;, matching any words that start with any two letters followed by a &lt;code&gt;d&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;structural-query-parts&#34;&gt;Structural query parts&lt;/h3&gt;
&lt;h4 id=&#34;andqueryoperatoriquerypart-left-iquerypart-right&#34;&gt;&lt;code&gt;AndQueryOperator(IQueryPart left, IQueryPart right)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Intersects the results of two query parts. In other words, only matches that appear on &lt;strong&gt;both&lt;/strong&gt; sides will be returned.&lt;/p&gt;
&lt;h4 id=&#34;orqueryoperatoriquerypart-left-iquerypart-right&#34;&gt;&lt;code&gt;OrQueryOperator(IQueryPart left, IQueryPart right)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;|&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unions the results of two query parts. In other words, a deduplicated set of matches on &lt;strong&gt;both&lt;/strong&gt; sides will be returned.&lt;/p&gt;
&lt;h4 id=&#34;bracketedquerypartiquerypart-statement&#34;&gt;&lt;code&gt;BracketedQueryPart(IQueryPart statement)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This can be used to group other query parts together, ensure they are executed in the right order.&lt;/p&gt;
&lt;h4 id=&#34;adjacentwordsquerypartireadonlylistiquerypart-matches&#34;&gt;&lt;code&gt;AdjacentWordsQueryPart(IReadOnlyList&amp;lt;IQueryPart&amp;gt; matches)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A query part requiring that a series of matches must appear in a document in sequence.&lt;/p&gt;
&lt;h4 id=&#34;fieldfilterqueryoperatorstring-fieldname-byte-fieldid-iquerypart-statement&#34;&gt;&lt;code&gt;FieldFilterQueryOperator(string fieldName, byte fieldId, IQueryPart statement)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;field=&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Restricts the resulting item matches to only those that include matching tokens in a specific field.&lt;/p&gt;
&lt;h4 id=&#34;nearqueryoperatoriquerypart-left-iquerypart-right-int-tolerance--5&#34;&gt;&lt;code&gt;NearQueryOperator(IQueryPart left, IQueryPart right, int tolerance = 5)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;~n&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Produces an intersection of two &lt;code&gt;IQueryPart&lt;/code&gt;s, restricting an item&amp;rsquo;s field matches such that the locations are close to one another.&lt;/p&gt;
&lt;p&gt;Items that result in no field matches are filtered out.&lt;/p&gt;
&lt;h4 id=&#34;precedingnearqueryoperatoriquerypart-left-iquerypart-right-int-tolerance--5&#34;&gt;&lt;code&gt;PrecedingNearQueryOperator(IQueryPart left, IQueryPart right, int tolerance = 5)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;~n&amp;gt;&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Produces an intersection of two &lt;code&gt;IQueryPart&lt;/code&gt;s, restricting an item&amp;rsquo;s field matches such that the locations of the first appear before the locations of the second and within a specified tolerance.&lt;/p&gt;
&lt;p&gt;Items that result in no field matches are filtered out.&lt;/p&gt;
&lt;h4 id=&#34;precedingqueryoperatoriquerypart-left-iquerypart-right&#34;&gt;&lt;code&gt;PrecedingQueryOperator(IQueryPart left, IQueryPart right)&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; in LIFTI query syntax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Produces an intersection of two &lt;code&gt;IQueryPart&lt;/code&gt;s, restricting an item&amp;rsquo;s field matches such that the locations of the first appear before the locations of the second.&lt;/p&gt;
&lt;p&gt;Items that result in no field matches are filtered out.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: IndexNavigator</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/using-the-index-navigator/</link>
      <pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/using-the-index-navigator/</guid>
      <description>
        
        
        &lt;p&gt;When processing a search query, LIFTI leverages a class called &lt;code&gt;IndexNavigator&lt;/code&gt; which allows for a character-by-character
navigation of the index.&lt;/p&gt;
&lt;p&gt;You can use an &lt;code&gt;IndexNavigator&lt;/code&gt; to do the same thing yourself. The example below demonstrates the following methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.Process&lt;/code&gt; Navigates (forward only) the nodes in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.GetExactMatches&lt;/code&gt; Gets all the matches at the current location in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.GetExactAndChildMatches&lt;/code&gt; Gets the exact matches &lt;em&gt;and&lt;/em&gt; any matches in subsequent child nodes. This is the equivalent to a wildcard search.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.EnumerateIndexedTokens&lt;/code&gt; Enumerates the words (tokens) that were indexed under the current location. This essentaially allows for a reverse-engineering of words stored in the index, albeit in their index normalized form.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Task&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RunAsync&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create a full text index with default settings&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FullTextIndexBuilder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;().&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Build&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Index some sample data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AddAsync&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Item1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Catastrophe&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AddAsync&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Item2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Casualty&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AddAsync&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Item3&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Cat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// To programatically search the index, create an index navigator instance &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// from the index snapshot.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;CreateNavigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Navigate through the letters &amp;#39;C&amp;#39; and &amp;#39;A&amp;#39; (these will be the characters in their &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// *index normalized* form)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Process&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;CA&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AsSpan&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// There will be no exact matches at the current position in the index, but 3 matches &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// when considering child matches, i.e. words starting with &amp;#34;ca&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Writes: Exact matches: 0 Exact and child matches: 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;WriteMatchState&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Navigating through the &amp;#39;T&amp;#39; of Catastrophe and Cat, but not Casualty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Process&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;T&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Writes: Exact matches: 1 Exact and child matches: 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;WriteMatchState&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Use EnumerateIndexedTokens to reverse-engineer the words that have been indexed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// under the current location in the index, in their normalized form.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Writes:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// CAT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// CATASTROPHE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;token&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;EnumerateIndexedTokens&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#000&#34;&gt;Console&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WriteLine&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;token&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// The Process method returns true if navigation was successful, and false otherwise:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Writes: True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;Console&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WriteLine&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Process&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Writes: False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;Console&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WriteLine&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Process&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ZOOOOM&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;WriteMatchState&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IIndexNavigator&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;navigator&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;Console&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WriteLine&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;$@&amp;#34;Exact matches: {navigator.GetExactMatches().Matches.Count} 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;Exact and child matches: {navigator.GetExactAndChildMatches().Matches.Count}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Search Results</title>
      <link>https://mikegoatly.github.io/lifti/docs/searching/search-results/</link>
      <pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mikegoatly.github.io/lifti/docs/searching/search-results/</guid>
      <description>
        
        
        &lt;h2 id=&#34;search-result-order&#34;&gt;Search result order&lt;/h2&gt;
&lt;p&gt;Search results are returned sorted according to the total document score, in descending order. See &lt;a href=&#34;./scoring&#34;&gt;scoring&lt;/a&gt; for more information.&lt;/p&gt;
&lt;h2 id=&#34;searchresultlttgt&#34;&gt;SearchResult&amp;lt;T&amp;gt;&lt;/h2&gt;
&lt;h3 id=&#34;t-item--get-&#34;&gt;T Item { get; }&lt;/h3&gt;
&lt;p&gt;The item that matched the search criteria.&lt;/p&gt;
&lt;h3 id=&#34;ireadonlylistltfieldsearchresultgt-fieldmatches--get-&#34;&gt;IReadOnlyList&amp;lt;FieldSearchResult&amp;gt; FieldMatches { get; }&lt;/h3&gt;
&lt;p&gt;The fields that were matched for the item. Each of these is scored independently and provides detailed information
about the location of the words that were matched.&lt;/p&gt;
&lt;h3 id=&#34;double-score--get-&#34;&gt;double Score { get; }&lt;/h3&gt;
&lt;p&gt;The overall score for this match. This is a sum of the scores for this instance&amp;rsquo;s FieldMatches.&lt;/p&gt;
&lt;h2 id=&#34;fieldsearchresult&#34;&gt;FieldSearchResult&lt;/h2&gt;
&lt;h3 id=&#34;string-foundin--get-&#34;&gt;string FoundIn { get; }&lt;/h3&gt;
&lt;p&gt;The name of the field that the search results were found in. This will be one of the field names configured when the index was built, or &lt;code&gt;Unspecified&lt;/code&gt; if no fields were configured.&lt;/p&gt;
&lt;h3 id=&#34;double-score--get--1&#34;&gt;double Score { get; }&lt;/h3&gt;
&lt;p&gt;The score for this particular field.&lt;/p&gt;
&lt;h3 id=&#34;ireadonlylistltwordlocationgt-locations--get-&#34;&gt;IReadOnlyList&amp;lt;WordLocation&amp;gt; Locations { get; }&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;WordLocation&lt;/code&gt; instances for the locations of the matched words in the field.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
